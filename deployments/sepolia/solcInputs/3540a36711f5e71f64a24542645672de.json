{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/FundMe.sol": {
      "content": "// Get funds from users\n// Withdraw funds\n// Set a minimum funding value in USD\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport './PriceConverter.sol';\n\nerror FundMe__NotOwner();\n\n/**\n * @title A contract for crowd funding\n * @author TristÃ¡n Vaquero\n * @notice This contract is a demo of a sample funding contract\n * @dev This implements price feeds as our library\n */\ncontract FundMe {\n    using PriceConverter for uint256;\n\n    uint256 public constant MINIMUM_USD = 50 * 1e18; // variables that wont change -> constant\n    address[] private s_funders;\n    mapping(address => uint256) private s_addressToAmountFunded; // s_ means its a storage variable (its going to consume a lot of GAS)\n    address private immutable i_owner; // variables that we set one time outside of the same line that they are declared -> immutable\n    AggregatorV3Interface private s_priceFeed; // global variable created and obtaining its value in the constructor so we dont have to hardcode the priceFeed and we can pass it dynamically.\n\n    // modifiers: key words that we can add at the function declaration to modify the functions with a functionality.\n    // When we call a function with a modifer, we are saying: before executing the function, execute the code in the modifer\n    modifier onlyOwner() {\n        // require(msg.sender == i_owner, NotOwner()); // we want that only the owner of the contract is able to withdraw money; the metamask address of the person deploying the contract must be the same to the metamask address of the person withdrawing money.\n        if (msg.sender != i_owner) {\n            revert FundMe__NotOwner();\n        }\n        _; // do the function code. We can put it above to do first the function and then the modifier.\n    }\n\n    // function that automatically is called when we deploy the contract -> like a normal constructor. Its called immediately after deploying the contract.\n    constructor(address priceFeedAddress) {\n        i_owner = msg.sender; // msg.sender = the person who is deploying the contract (address on metamask)\n        s_priceFeed = AggregatorV3Interface(priceFeedAddress);\n    }\n\n    // What happens if someone sends this contract ETH withput calling the fund function\n    // The ETH sent to this contract will just go to the contract but we wouldnt have any track of those people\n    // receive\n    // fallback\n    receive() external payable {\n        fund();\n    }\n\n    fallback() external payable {\n        fund();\n    }\n\n    // contract addresses can hold funds too since every time we deploy a contract we get an address similar to a wallet.\n    // payable = be able to access the value attribute when deploying the App\n    /**\n     * @notice This function funds this contract\n     * @dev This implements price feeds as our library\n     */\n    function fund() public payable {\n        // We want to be able to set a minimum fund amount in USD (get the ETH price / 50 -> eth converter and put the 0.X in ETH -> copy the wei and put it on Value -> run fund\n        // Send ETH to this contract:\n        require(\n            msg.value.getConversionRate(s_priceFeed) > MINIMUM_USD,\n            'ERROR: Didnt send enough ETH!'\n        ); // the minimum value is 1 ETH (1e18 == 1 * 10 ^ 18 == 1 ETH in WEI). \"require\" is an \"if\". If the condition is not met, all the actions from before will be undone.\n        s_funders.push(msg.sender); // msg.sender = address sending (keeping track of the donators donating to our contract)\n        s_addressToAmountFunded[msg.sender] = msg.value;\n    }\n\n    // withdraw funds out of this contract so they can buy things for this project\n    function withdraw() public onlyOwner {\n        // require(msg.sender == owner, \"Sender is not the owner\"); // we want that only the owner of the contract is able to withdraw money; to avoid using require all the time, we can create a modifier\n\n        // reset funders because we are returning all the money from them\n        for (\n            uint256 fudnerIndex = 0;\n            fudnerIndex < s_funders.length;\n            fudnerIndex++\n        ) {\n            address funder = s_funders[fudnerIndex]; // get the funder\n            s_addressToAmountFunded[funder] = 0; // reset funds\n        }\n\n        // reset array of funders\n        s_funders = new address[](0); // reset array with 0 objects/elements to start with\n\n        // withdraw funds\n        // 3 ways:\n\n        // 1. transfer (if fails, throws an error and automatically reverts the transaction)\n        // msg.sender = type address; payable(msg.sender) = payable address -> to be able to send the tokens\n        // payable(msg.sender).transfer(address(this).balance); // payable(msg.sender) -> gets the address where we are going to send the money; address(this).balance -> amount we are going to transfer (this = contract)\n\n        // 2. send (doesent throw an error or revert the transaction. Returns a boolean if the transfer was successfull or not)\n        // bool sendSuccess = payable(msg.sender).send(address(this).balance);\n        // require(sendSuccess, \"Send failed\"); // check the transaction to revert it if it fails\n\n        // 3. call (recommended way. Allows to call any function)\n        (bool callSuccess, ) = payable(msg.sender).call{\n            value: address(this).balance\n        }(''); // address(this) = contract ; .balance = balance of the contract\n        require(callSuccess, 'Send failed');\n    }\n\n    // withdraw function but more GAS efficient\n    function cheaperWithdraw() public payable onlyOwner {\n        address[] memory funders = s_funders; // we read once the funders array and store it in memory so we dont have to constantly read and waste GAS (mappings cannot be stored in memory)\n        for (\n            uint256 funderIndex = 0;\n            funderIndex < funders.length;\n            funderIndex++\n        ) {\n            address funder = funders[funderIndex];\n            s_addressToAmountFunded[funder] = 0;\n        }\n        s_funders = new address[](0);\n        (bool success, ) = i_owner.call{value: address(this).balance}('');\n        require(success, 'Send failed');\n    }\n\n    function getOwner() public view returns (address) {\n        return i_owner;\n    }\n\n    function getFunder(uint256 index) public view returns (address) {\n        return s_funders[index];\n    }\n\n    function getAddressToAmountFunded(\n        address funder\n    ) public view returns (uint256) {\n        return s_addressToAmountFunded[funder];\n    }\n\n    function getPriceFeed() public view returns (AggregatorV3Interface) {\n        return s_priceFeed;\n    }\n}\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {AggregatorV3Interface} from '@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol'; // import directly from GitHub the interface\n\nlibrary PriceConverter {\n    // function to convert msg.value to the USD equivalent\n    function getPrice(\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        // ABI of the contract we want to interact with\n        // Address of the contract we want to interact with: 0x694AA1769357215DE4FAC081bf1f309aDC325306 (https://docs.chain.link/data-feeds/price-feeds/addresses?network=ethereum&page=1)\n        // AggregatorV3Interface give us the minimalistic ABI to interact with a contract\n        (, int price, , , ) = priceFeed.latestRoundData(); // price = price of ETH in terms of USD (8 decimals -> 3000.00000000 -> We need 18 decimals to match msg.value); if the function returns more than one value and we are not going to use it, we can leave them blank\n        return uint256(price * 1e10);\n    }\n\n    function getConversionRate(\n        uint256 ethAmount,\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        uint256 ethPrice = getPrice(priceFeed);\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18; // it has 18 zeros so we have to devide\n        return ethAmountInUsd;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}